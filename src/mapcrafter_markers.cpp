#include <vector>

#include "mapcraftercore/util.h"
#include "mapcraftercore/config/mapcrafterconfig.h"
#include "mapcraftercore/mc/world.h"
#include "mapcraftercore/mc/worldentities.h"

#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <map>
#include <boost/program_options.hpp>
#include <boost/filesystem.hpp>

namespace po = boost::program_options;
namespace fs = boost::filesystem;

namespace util = mapcrafter::util;
namespace config = mapcrafter::config;
namespace mc = mapcrafter::mc;

struct Marker {
	mc::BlockPos pos;
	std::string title, text;

	std::string toJSON() const {
		std::string json = "{";
		json += "\"pos\": [" + util::str(pos.x) + "," + util::str(pos.z) + "," + util::str(pos.y) + "], ";
		json += "\"title\": \"" + util::escapeJSON(title) + "\", ";
		json += "\"text\": \"" + util::escapeJSON(text) + "\", ";
		return json + "}";
	}
};

// map (marker group name -> map ( world name -> array of markers) )
typedef std::map<std::string, std::map<std::string, std::vector<Marker> > > Markers;

void findMarkers(const config::MapcrafterConfig& config, Markers& markers_found,
		bool verbose = false) {
	auto worlds = config.getWorlds();
	auto markers = config.getMarkers();
	for (auto world_it = worlds.begin(); world_it != worlds.end(); ++world_it) {
		mc::WorldCrop world_crop = world_it->second.getWorldCrop();
		mc::World world(world_it->second.getInputDir().string(),
				world_it->second.getDimension());
		world.setWorldCrop(world_crop);
		if (!world.load()) {
			std::cerr << "Error: Unable to load world " << world_it->first << "!" << std::endl;
			continue;
		}

		mc::WorldEntitiesCache entities(world);
		entities.update(verbose);

		// use name of the world section as world name, not the world_name
		std::string world_name = world_it->second.getShortName();
		std::vector<mc::SignEntity> signs = entities.getSigns(world.getWorldCrop());
		for (auto sign_it = signs.begin(); sign_it != signs.end(); ++sign_it) {
			// don't use signs not contained in the world boundaries
			if (!world_crop.isBlockContainedXZ(sign_it->getPos())
					&& !world_crop.isBlockContainedY(sign_it->getPos()))
				continue;
			for (auto marker_it = markers.begin(); marker_it != markers.end(); ++marker_it) {
				if (!marker_it->matchesSign(*sign_it))
					continue;
				Marker marker;
				marker.pos = sign_it->getPos();
				marker.title = marker_it->formatTitle(*sign_it);
				marker.text = marker_it->formatText(*sign_it);
				markers_found[marker_it->getShortName()][world_name].push_back(marker);
				break;
			}
		}
	}
}

std::string createMarkersJSON(const config::MapcrafterConfig& config,
		const Markers& markers_found) {
	auto markers = config.getMarkers();
	std::stringstream ss;

	ss << "// This file is automatically generated. Do not edit this file." << std::endl;
	ss << "// Use the markers.js for your own markers instead." << std::endl << std::endl;
	ss << "MAPCRAFTER_MARKERS_GENERATED = [" << std::endl;
	for (auto marker_config_it = markers.begin(); marker_config_it != markers.end();
			++marker_config_it) {
		config::MarkerSection marker_config = *marker_config_it;
		std::string group = marker_config.getShortName();
		ss << "  {" << std::endl;
		ss << "    \"id\" : \"" << group << "\"," << std::endl;
		ss << "    \"name\" : \"" << marker_config.getLongName() << "\"," << std::endl;
		if (!marker_config.getIcon().empty()) {
			ss << "    \"icon\" : \"" << marker_config.getIcon() << "\"," << std::endl;
			if (!marker_config.getIconSize().empty())
				ss << "    \"iconSize\" : " << marker_config.getIconSize() << "," << std::endl;
		}
		ss << "    \"showDefault\" : ";
		ss << (marker_config.isShownByDefault() ? "true" : "false") << "," << std::endl;
		ss << "    \"markers\" : {" << std::endl;

		if (!markers_found.count(group)) {
			ss << "    }," << std::endl;
			ss << "  }," << std::endl;
			continue;
		}

		for (auto world_it = markers_found.at(group).begin();
				world_it != markers_found.at(group).end(); ++world_it) {
			ss << "      \"" << world_it->first << "\" : [" << std::endl;
			for (auto marker_it = world_it->second.begin();
					marker_it != world_it->second.end(); ++marker_it) {
				ss << "        " << marker_it->toJSON() << "," << std::endl;
			}
			ss << "      ]," << std::endl;
		}
		ss << "    }," << std::endl;
		ss << "  }," << std::endl;
	}
	ss << "];" << std::endl;

	return ss.str();
}

int main(int argc, char** argv) {
	std::string config_file;
	std::string output_file;
 
	po::options_description all("Allowed options");
	all.add_options()
		("help,h", "shows this help message")
		("verbose,v", "verbose blah blah")

		("config,c", po::value<std::string>(&config_file),
			"the path to the configuration file (required)")
		("output-file,o", po::value<std::string>(&output_file),
			"file to write the generated markers to, "
			"defaults to markers-generated.js in the output directory.");

	po::variables_map vm;
	try {
		po::store(po::parse_command_line(argc, argv, all), vm);
	} catch (po::error& ex) {
		std::cout << "There is a problem parsing the command line arguments: "
				<< ex.what() << std::endl << std::endl;
		std::cout << all << std::endl;
		return 1;
	}

	po::notify(vm);

	if (vm.count("help")) {
		std::cout << all << std::endl;
		return 1;
	}

	if (!vm.count("config")) {
		std::cerr << "You have to specify a configuration file!" << std::endl;
		return 1;
	}

	config::MapcrafterConfig config;
	config::ValidationMap validation = config.parse(config_file);

	if (!validation.isEmpty()) {
		if (validation.isCritical())
			LOG(FATAL) << "Your configuration file is invalid!";
		else
			LOG(WARNING) << "Some notes on your configuration file:";
		validation.log();
		LOG(WARNING) << "Please read the documentation about the new configuration file format.";
	}

	Markers markers_found;
	findMarkers(config, markers_found, vm.count("verbose"));
	std::string markers_json = createMarkersJSON(config, markers_found);

	if (output_file == "-")
		std::cout << markers_json;
	else {
		if (output_file == "")
			output_file = config.getOutputPath("markers-generated.js").string();
		std::ofstream out(output_file);
		out << markers_json;
		out.close();
		if (!out) {
			std::cerr << "Error: Unable to write to file '" << output_file << "'!" << std::endl;
			return 1;
		}
	}
}
